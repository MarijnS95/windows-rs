// Bindings generated by `windows-bindgen` 0.52.0

#![allow(
    non_snake_case,
    non_upper_case_globals,
    non_camel_case_types,
    dead_code,
    clippy::all
)]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct BOOL(pub i32);
impl ::core::default::Default for BOOL {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::clone::Clone for BOOL {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::marker::Copy for BOOL {}
impl ::core::fmt::Debug for BOOL {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("BOOL").field(&self.0).finish()
    }
}
impl ::windows_core::TypeKind for BOOL {
    type TypeKind = ::windows_core::CopyType;
}
pub const CLSID_DxcCompiler: ::windows_core::GUID =
    ::windows_core::GUID::from_u128(0x73e22d93_e6ce_47f3_b5bf_f0664f39c1b0);
pub const CLSID_DxcLibrary: ::windows_core::GUID =
    ::windows_core::GUID::from_u128(0x6245d6af_66e0_48fd_80b4_4d271796748c);
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct DXC_CP(pub u32);
impl ::core::marker::Copy for DXC_CP {}
impl ::core::clone::Clone for DXC_CP {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DXC_CP {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for DXC_CP {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for DXC_CP {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DXC_CP").field(&self.0).finish()
    }
}
pub const DXC_CP_UTF8: DXC_CP = DXC_CP(65001u32);
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct DXC_OUT_KIND(pub i32);
impl ::core::marker::Copy for DXC_OUT_KIND {}
impl ::core::clone::Clone for DXC_OUT_KIND {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DXC_OUT_KIND {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for DXC_OUT_KIND {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for DXC_OUT_KIND {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DXC_OUT_KIND").field(&self.0).finish()
    }
}
pub const DXC_OUT_PDB: DXC_OUT_KIND = DXC_OUT_KIND(3i32);
#[repr(C)]
pub struct DxcBuffer {
    pub Ptr: *const ::core::ffi::c_void,
    pub Size: usize,
    pub Encoding: u32,
}
impl ::core::marker::Copy for DxcBuffer {}
impl ::core::clone::Clone for DxcBuffer {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DxcBuffer {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DxcBuffer")
            .field("Ptr", &self.Ptr)
            .field("Size", &self.Size)
            .field("Encoding", &self.Encoding)
            .finish()
    }
}
impl ::windows_core::TypeKind for DxcBuffer {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for DxcBuffer {
    fn eq(&self, other: &Self) -> bool {
        self.Ptr == other.Ptr && self.Size == other.Size && self.Encoding == other.Encoding
    }
}
impl ::core::cmp::Eq for DxcBuffer {}
impl ::core::default::Default for DxcBuffer {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type DxcCreateInstanceProc = ::core::option::Option<
    unsafe extern "system" fn(
        rclsid: *const ::windows_core::GUID,
        riid: *const ::windows_core::GUID,
        ppv: *mut *mut ::core::ffi::c_void,
    ) -> ::windows_core::HRESULT,
>;
#[repr(C)]
pub struct FILETIME {
    pub dwLowDateTime: u32,
    pub dwHighDateTime: u32,
}
impl ::core::marker::Copy for FILETIME {}
impl ::core::clone::Clone for FILETIME {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILETIME {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILETIME")
            .field("dwLowDateTime", &self.dwLowDateTime)
            .field("dwHighDateTime", &self.dwHighDateTime)
            .finish()
    }
}
impl ::windows_core::TypeKind for FILETIME {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILETIME {
    fn eq(&self, other: &Self) -> bool {
        self.dwLowDateTime == other.dwLowDateTime && self.dwHighDateTime == other.dwHighDateTime
    }
}
impl ::core::cmp::Eq for FILETIME {}
impl ::core::default::Default for FILETIME {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct HANDLE(pub isize);
impl HANDLE {
    pub fn is_invalid(&self) -> bool {
        self.0 == -1 || self.0 == 0
    }
}
impl ::core::default::Default for HANDLE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::clone::Clone for HANDLE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::marker::Copy for HANDLE {}
impl ::core::fmt::Debug for HANDLE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("HANDLE").field(&self.0).finish()
    }
}
impl ::windows_core::TypeKind for HANDLE {
    type TypeKind = ::windows_core::CopyType;
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct HEAP_FLAGS(pub u32);
impl ::core::marker::Copy for HEAP_FLAGS {}
impl ::core::clone::Clone for HEAP_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for HEAP_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for HEAP_FLAGS {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for HEAP_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("HEAP_FLAGS").field(&self.0).finish()
    }
}
impl HEAP_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for HEAP_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for HEAP_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for HEAP_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for HEAP_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for HEAP_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq, ::core::fmt::Debug, ::core::clone::Clone)]
pub struct IDxcBlob(::windows_core::IUnknown);
impl IDxcBlob {
    pub unsafe fn GetBufferPointer(&self) -> *mut ::core::ffi::c_void {
        (::windows_core::Interface::vtable(self).GetBufferPointer)(
            ::windows_core::Interface::as_raw(self),
        )
    }
    pub unsafe fn GetBufferSize(&self) -> usize {
        (::windows_core::Interface::vtable(self).GetBufferSize)(::windows_core::Interface::as_raw(
            self,
        ))
    }
}
::windows_core::imp::interface_hierarchy!(IDxcBlob, ::windows_core::IUnknown);
unsafe impl ::windows_core::Interface for IDxcBlob {
    type Vtable = IDxcBlob_Vtbl;
}
unsafe impl ::windows_core::ComInterface for IDxcBlob {
    const IID: ::windows_core::GUID =
        ::windows_core::GUID::from_u128(0x8ba5fb08_5195_40e2_ac58_0d989c3a0102);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDxcBlob_Vtbl {
    pub base__: ::windows_core::IUnknown_Vtbl,
    pub GetBufferPointer:
        unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> *mut ::core::ffi::c_void,
    pub GetBufferSize: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> usize,
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq, ::core::fmt::Debug, ::core::clone::Clone)]
pub struct IDxcBlobEncoding(::windows_core::IUnknown);
impl IDxcBlobEncoding {
    pub unsafe fn GetBufferPointer(&self) -> *mut ::core::ffi::c_void {
        (::windows_core::Interface::vtable(self)
            .base__
            .GetBufferPointer)(::windows_core::Interface::as_raw(self))
    }
    pub unsafe fn GetBufferSize(&self) -> usize {
        (::windows_core::Interface::vtable(self).base__.GetBufferSize)(
            ::windows_core::Interface::as_raw(self),
        )
    }
    pub unsafe fn GetEncoding(
        &self,
        pknown: *mut BOOL,
        pcodepage: *mut DXC_CP,
    ) -> ::windows_core::Result<()> {
        (::windows_core::Interface::vtable(self).GetEncoding)(
            ::windows_core::Interface::as_raw(self),
            pknown,
            pcodepage,
        )
        .ok()
    }
}
::windows_core::imp::interface_hierarchy!(IDxcBlobEncoding, ::windows_core::IUnknown, IDxcBlob);
unsafe impl ::windows_core::Interface for IDxcBlobEncoding {
    type Vtable = IDxcBlobEncoding_Vtbl;
}
unsafe impl ::windows_core::ComInterface for IDxcBlobEncoding {
    const IID: ::windows_core::GUID =
        ::windows_core::GUID::from_u128(0x7241d424_2646_4191_97c0_98e96e42fc68);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDxcBlobEncoding_Vtbl {
    pub base__: IDxcBlob_Vtbl,
    pub GetEncoding: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pknown: *mut BOOL,
        pcodepage: *mut DXC_CP,
    ) -> ::windows_core::HRESULT,
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq, ::core::fmt::Debug, ::core::clone::Clone)]
pub struct IDxcBlobUtf16(::windows_core::IUnknown);
impl IDxcBlobUtf16 {
    pub unsafe fn GetBufferPointer(&self) -> *mut ::core::ffi::c_void {
        (::windows_core::Interface::vtable(self)
            .base__
            .base__
            .GetBufferPointer)(::windows_core::Interface::as_raw(self))
    }
    pub unsafe fn GetBufferSize(&self) -> usize {
        (::windows_core::Interface::vtable(self)
            .base__
            .base__
            .GetBufferSize)(::windows_core::Interface::as_raw(self))
    }
    pub unsafe fn GetEncoding(
        &self,
        pknown: *mut BOOL,
        pcodepage: *mut DXC_CP,
    ) -> ::windows_core::Result<()> {
        (::windows_core::Interface::vtable(self).base__.GetEncoding)(
            ::windows_core::Interface::as_raw(self),
            pknown,
            pcodepage,
        )
        .ok()
    }
    pub unsafe fn GetStringPointer(&self) -> ::windows_core::PCWSTR {
        (::windows_core::Interface::vtable(self).GetStringPointer)(
            ::windows_core::Interface::as_raw(self),
        )
    }
    pub unsafe fn GetStringLength(&self) -> usize {
        (::windows_core::Interface::vtable(self).GetStringLength)(
            ::windows_core::Interface::as_raw(self),
        )
    }
}
::windows_core::imp::interface_hierarchy!(
    IDxcBlobUtf16,
    ::windows_core::IUnknown,
    IDxcBlob,
    IDxcBlobEncoding
);
unsafe impl ::windows_core::Interface for IDxcBlobUtf16 {
    type Vtable = IDxcBlobUtf16_Vtbl;
}
unsafe impl ::windows_core::ComInterface for IDxcBlobUtf16 {
    const IID: ::windows_core::GUID =
        ::windows_core::GUID::from_u128(0xa3f84eab_0faa_497e_a39c_ee6ed60b2d84);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDxcBlobUtf16_Vtbl {
    pub base__: IDxcBlobEncoding_Vtbl,
    pub GetStringPointer:
        unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows_core::PCWSTR,
    pub GetStringLength: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> usize,
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq, ::core::fmt::Debug, ::core::clone::Clone)]
pub struct IDxcCompiler3(::windows_core::IUnknown);
impl IDxcCompiler3 {
    pub unsafe fn Compile<P0, T>(
        &self,
        psource: *const DxcBuffer,
        parguments: ::core::option::Option<&[::windows_core::PCWSTR]>,
        pincludehandler: P0,
    ) -> ::windows_core::Result<T>
    where
        P0: ::windows_core::IntoParam<IDxcIncludeHandler>,
        T: ::windows_core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows_core::Interface::vtable(self).Compile)(
            ::windows_core::Interface::as_raw(self),
            psource,
            ::core::mem::transmute(
                parguments
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
            parguments.as_deref().map_or(0, |slice| slice.len() as _),
            pincludehandler.into_param().abi(),
            &<T as ::windows_core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn Disassemble<T>(&self, pobject: *const DxcBuffer) -> ::windows_core::Result<T>
    where
        T: ::windows_core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows_core::Interface::vtable(self).Disassemble)(
            ::windows_core::Interface::as_raw(self),
            pobject,
            &<T as ::windows_core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
}
::windows_core::imp::interface_hierarchy!(IDxcCompiler3, ::windows_core::IUnknown);
unsafe impl ::windows_core::Interface for IDxcCompiler3 {
    type Vtable = IDxcCompiler3_Vtbl;
}
unsafe impl ::windows_core::ComInterface for IDxcCompiler3 {
    const IID: ::windows_core::GUID =
        ::windows_core::GUID::from_u128(0x228b4687_5a6a_4730_900c_9702b2203f54);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDxcCompiler3_Vtbl {
    pub base__: ::windows_core::IUnknown_Vtbl,
    pub Compile: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        psource: *const DxcBuffer,
        parguments: *const ::windows_core::PCWSTR,
        argcount: u32,
        pincludehandler: *mut ::core::ffi::c_void,
        riid: *const ::windows_core::GUID,
        ppresult: *mut *mut ::core::ffi::c_void,
    ) -> ::windows_core::HRESULT,
    pub Disassemble: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pobject: *const DxcBuffer,
        riid: *const ::windows_core::GUID,
        ppresult: *mut *mut ::core::ffi::c_void,
    ) -> ::windows_core::HRESULT,
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq, ::core::fmt::Debug, ::core::clone::Clone)]
pub struct IDxcIncludeHandler(::windows_core::IUnknown);
impl IDxcIncludeHandler {
    pub unsafe fn LoadSource<P0>(&self, pfilename: P0) -> ::windows_core::Result<IDxcBlob>
    where
        P0: ::windows_core::IntoParam<::windows_core::PCWSTR>,
    {
        let mut result__ = ::std::mem::zeroed();
        (::windows_core::Interface::vtable(self).LoadSource)(
            ::windows_core::Interface::as_raw(self),
            pfilename.into_param().abi(),
            &mut result__,
        )
        .from_abi(result__)
    }
}
::windows_core::imp::interface_hierarchy!(IDxcIncludeHandler, ::windows_core::IUnknown);
unsafe impl ::windows_core::Interface for IDxcIncludeHandler {
    type Vtable = IDxcIncludeHandler_Vtbl;
}
unsafe impl ::windows_core::ComInterface for IDxcIncludeHandler {
    const IID: ::windows_core::GUID =
        ::windows_core::GUID::from_u128(0x7f61fc7d_950d_467f_b3e3_3c02fb49187c);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDxcIncludeHandler_Vtbl {
    pub base__: ::windows_core::IUnknown_Vtbl,
    pub LoadSource: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pfilename: ::windows_core::PCWSTR,
        ppincludesource: *mut *mut ::core::ffi::c_void,
    ) -> ::windows_core::HRESULT,
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq, ::core::fmt::Debug, ::core::clone::Clone)]
pub struct IDxcLibrary(::windows_core::IUnknown);
impl IDxcLibrary {
    pub unsafe fn SetMalloc<P0>(&self, pmalloc: P0) -> ::windows_core::Result<()>
    where
        P0: ::windows_core::IntoParam<IMalloc>,
    {
        (::windows_core::Interface::vtable(self).SetMalloc)(
            ::windows_core::Interface::as_raw(self),
            pmalloc.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn CreateBlobFromBlob<P0>(
        &self,
        pblob: P0,
        offset: u32,
        length: u32,
    ) -> ::windows_core::Result<IDxcBlob>
    where
        P0: ::windows_core::IntoParam<IDxcBlob>,
    {
        let mut result__ = ::std::mem::zeroed();
        (::windows_core::Interface::vtable(self).CreateBlobFromBlob)(
            ::windows_core::Interface::as_raw(self),
            pblob.into_param().abi(),
            offset,
            length,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateBlobFromFile<P0>(
        &self,
        pfilename: P0,
        codepage: ::core::option::Option<*const DXC_CP>,
    ) -> ::windows_core::Result<IDxcBlobEncoding>
    where
        P0: ::windows_core::IntoParam<::windows_core::PCWSTR>,
    {
        let mut result__ = ::std::mem::zeroed();
        (::windows_core::Interface::vtable(self).CreateBlobFromFile)(
            ::windows_core::Interface::as_raw(self),
            pfilename.into_param().abi(),
            ::core::mem::transmute(codepage.unwrap_or(::std::ptr::null())),
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateBlobWithEncodingFromPinned(
        &self,
        ptext: *const ::core::ffi::c_void,
        size: u32,
        codepage: DXC_CP,
    ) -> ::windows_core::Result<IDxcBlobEncoding> {
        let mut result__ = ::std::mem::zeroed();
        (::windows_core::Interface::vtable(self).CreateBlobWithEncodingFromPinned)(
            ::windows_core::Interface::as_raw(self),
            ptext,
            size,
            codepage,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateBlobWithEncodingOnHeapCopy(
        &self,
        ptext: *const ::core::ffi::c_void,
        size: u32,
        codepage: DXC_CP,
    ) -> ::windows_core::Result<IDxcBlobEncoding> {
        let mut result__ = ::std::mem::zeroed();
        (::windows_core::Interface::vtable(self).CreateBlobWithEncodingOnHeapCopy)(
            ::windows_core::Interface::as_raw(self),
            ptext,
            size,
            codepage,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateBlobWithEncodingOnMalloc<P0>(
        &self,
        ptext: *const ::core::ffi::c_void,
        pimalloc: P0,
        size: u32,
        codepage: DXC_CP,
    ) -> ::windows_core::Result<IDxcBlobEncoding>
    where
        P0: ::windows_core::IntoParam<IMalloc>,
    {
        let mut result__ = ::std::mem::zeroed();
        (::windows_core::Interface::vtable(self).CreateBlobWithEncodingOnMalloc)(
            ::windows_core::Interface::as_raw(self),
            ptext,
            pimalloc.into_param().abi(),
            size,
            codepage,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateIncludeHandler(&self) -> ::windows_core::Result<IDxcIncludeHandler> {
        let mut result__ = ::std::mem::zeroed();
        (::windows_core::Interface::vtable(self).CreateIncludeHandler)(
            ::windows_core::Interface::as_raw(self),
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateStreamFromBlobReadOnly<P0>(
        &self,
        pblob: P0,
    ) -> ::windows_core::Result<IStream>
    where
        P0: ::windows_core::IntoParam<IDxcBlob>,
    {
        let mut result__ = ::std::mem::zeroed();
        (::windows_core::Interface::vtable(self).CreateStreamFromBlobReadOnly)(
            ::windows_core::Interface::as_raw(self),
            pblob.into_param().abi(),
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetBlobAsUtf8<P0>(&self, pblob: P0) -> ::windows_core::Result<IDxcBlobEncoding>
    where
        P0: ::windows_core::IntoParam<IDxcBlob>,
    {
        let mut result__ = ::std::mem::zeroed();
        (::windows_core::Interface::vtable(self).GetBlobAsUtf8)(
            ::windows_core::Interface::as_raw(self),
            pblob.into_param().abi(),
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetBlobAsUtf16<P0>(&self, pblob: P0) -> ::windows_core::Result<IDxcBlobEncoding>
    where
        P0: ::windows_core::IntoParam<IDxcBlob>,
    {
        let mut result__ = ::std::mem::zeroed();
        (::windows_core::Interface::vtable(self).GetBlobAsUtf16)(
            ::windows_core::Interface::as_raw(self),
            pblob.into_param().abi(),
            &mut result__,
        )
        .from_abi(result__)
    }
}
::windows_core::imp::interface_hierarchy!(IDxcLibrary, ::windows_core::IUnknown);
unsafe impl ::windows_core::Interface for IDxcLibrary {
    type Vtable = IDxcLibrary_Vtbl;
}
unsafe impl ::windows_core::ComInterface for IDxcLibrary {
    const IID: ::windows_core::GUID =
        ::windows_core::GUID::from_u128(0xe5204dc7_d18c_4c3c_bdfb_851673980fe7);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDxcLibrary_Vtbl {
    pub base__: ::windows_core::IUnknown_Vtbl,
    pub SetMalloc: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pmalloc: *mut ::core::ffi::c_void,
    ) -> ::windows_core::HRESULT,
    pub CreateBlobFromBlob: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pblob: *mut ::core::ffi::c_void,
        offset: u32,
        length: u32,
        ppresult: *mut *mut ::core::ffi::c_void,
    ) -> ::windows_core::HRESULT,
    pub CreateBlobFromFile: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pfilename: ::windows_core::PCWSTR,
        codepage: *const DXC_CP,
        pblobencoding: *mut *mut ::core::ffi::c_void,
    ) -> ::windows_core::HRESULT,
    pub CreateBlobWithEncodingFromPinned: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        ptext: *const ::core::ffi::c_void,
        size: u32,
        codepage: DXC_CP,
        pblobencoding: *mut *mut ::core::ffi::c_void,
    ) -> ::windows_core::HRESULT,
    pub CreateBlobWithEncodingOnHeapCopy: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        ptext: *const ::core::ffi::c_void,
        size: u32,
        codepage: DXC_CP,
        pblobencoding: *mut *mut ::core::ffi::c_void,
    ) -> ::windows_core::HRESULT,
    pub CreateBlobWithEncodingOnMalloc: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        ptext: *const ::core::ffi::c_void,
        pimalloc: *mut ::core::ffi::c_void,
        size: u32,
        codepage: DXC_CP,
        pblobencoding: *mut *mut ::core::ffi::c_void,
    ) -> ::windows_core::HRESULT,
    pub CreateIncludeHandler: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        ppresult: *mut *mut ::core::ffi::c_void,
    ) -> ::windows_core::HRESULT,
    pub CreateStreamFromBlobReadOnly: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pblob: *mut ::core::ffi::c_void,
        ppstream: *mut *mut ::core::ffi::c_void,
    ) -> ::windows_core::HRESULT,
    pub GetBlobAsUtf8: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pblob: *mut ::core::ffi::c_void,
        pblobencoding: *mut *mut ::core::ffi::c_void,
    ) -> ::windows_core::HRESULT,
    pub GetBlobAsUtf16: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pblob: *mut ::core::ffi::c_void,
        pblobencoding: *mut *mut ::core::ffi::c_void,
    ) -> ::windows_core::HRESULT,
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq, ::core::fmt::Debug, ::core::clone::Clone)]
pub struct IDxcOperationResult(::windows_core::IUnknown);
impl IDxcOperationResult {
    pub unsafe fn GetStatus(&self) -> ::windows_core::Result<::windows_core::HRESULT> {
        let mut result__ = ::std::mem::zeroed();
        (::windows_core::Interface::vtable(self).GetStatus)(
            ::windows_core::Interface::as_raw(self),
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetResult(&self) -> ::windows_core::Result<IDxcBlob> {
        let mut result__ = ::std::mem::zeroed();
        (::windows_core::Interface::vtable(self).GetResult)(
            ::windows_core::Interface::as_raw(self),
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetErrorBuffer(&self) -> ::windows_core::Result<IDxcBlobEncoding> {
        let mut result__ = ::std::mem::zeroed();
        (::windows_core::Interface::vtable(self).GetErrorBuffer)(
            ::windows_core::Interface::as_raw(self),
            &mut result__,
        )
        .from_abi(result__)
    }
}
::windows_core::imp::interface_hierarchy!(IDxcOperationResult, ::windows_core::IUnknown);
unsafe impl ::windows_core::Interface for IDxcOperationResult {
    type Vtable = IDxcOperationResult_Vtbl;
}
unsafe impl ::windows_core::ComInterface for IDxcOperationResult {
    const IID: ::windows_core::GUID =
        ::windows_core::GUID::from_u128(0xcedb484a_d4e9_445a_b991_ca21ca157dc2);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDxcOperationResult_Vtbl {
    pub base__: ::windows_core::IUnknown_Vtbl,
    pub GetStatus: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pstatus: *mut ::windows_core::HRESULT,
    ) -> ::windows_core::HRESULT,
    pub GetResult: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        ppresult: *mut *mut ::core::ffi::c_void,
    ) -> ::windows_core::HRESULT,
    pub GetErrorBuffer: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pperrors: *mut *mut ::core::ffi::c_void,
    ) -> ::windows_core::HRESULT,
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq, ::core::fmt::Debug, ::core::clone::Clone)]
pub struct IDxcResult(::windows_core::IUnknown);
impl IDxcResult {
    pub unsafe fn GetStatus(&self) -> ::windows_core::Result<::windows_core::HRESULT> {
        let mut result__ = ::std::mem::zeroed();
        (::windows_core::Interface::vtable(self).base__.GetStatus)(
            ::windows_core::Interface::as_raw(self),
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetResult(&self) -> ::windows_core::Result<IDxcBlob> {
        let mut result__ = ::std::mem::zeroed();
        (::windows_core::Interface::vtable(self).base__.GetResult)(
            ::windows_core::Interface::as_raw(self),
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetErrorBuffer(&self) -> ::windows_core::Result<IDxcBlobEncoding> {
        let mut result__ = ::std::mem::zeroed();
        (::windows_core::Interface::vtable(self)
            .base__
            .GetErrorBuffer)(::windows_core::Interface::as_raw(self), &mut result__)
        .from_abi(result__)
    }
    pub unsafe fn HasOutput(&self, dxcoutkind: DXC_OUT_KIND) -> BOOL {
        (::windows_core::Interface::vtable(self).HasOutput)(
            ::windows_core::Interface::as_raw(self),
            dxcoutkind,
        )
    }
    pub unsafe fn GetOutput<T>(
        &self,
        dxcoutkind: DXC_OUT_KIND,
        ppoutputname: *mut ::core::option::Option<IDxcBlobUtf16>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows_core::Result<()>
    where
        T: ::windows_core::ComInterface,
    {
        (::windows_core::Interface::vtable(self).GetOutput)(
            ::windows_core::Interface::as_raw(self),
            dxcoutkind,
            &<T as ::windows_core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
            ::core::mem::transmute(ppoutputname),
        )
        .ok()
    }
    pub unsafe fn GetNumOutputs(&self) -> u32 {
        (::windows_core::Interface::vtable(self).GetNumOutputs)(::windows_core::Interface::as_raw(
            self,
        ))
    }
    pub unsafe fn GetOutputByIndex(&self, index: u32) -> DXC_OUT_KIND {
        (::windows_core::Interface::vtable(self).GetOutputByIndex)(
            ::windows_core::Interface::as_raw(self),
            index,
        )
    }
    pub unsafe fn PrimaryOutput(&self) -> DXC_OUT_KIND {
        (::windows_core::Interface::vtable(self).PrimaryOutput)(::windows_core::Interface::as_raw(
            self,
        ))
    }
}
::windows_core::imp::interface_hierarchy!(
    IDxcResult,
    ::windows_core::IUnknown,
    IDxcOperationResult
);
unsafe impl ::windows_core::Interface for IDxcResult {
    type Vtable = IDxcResult_Vtbl;
}
unsafe impl ::windows_core::ComInterface for IDxcResult {
    const IID: ::windows_core::GUID =
        ::windows_core::GUID::from_u128(0x58346cda_dde7_4497_9461_6f87af5e0659);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDxcResult_Vtbl {
    pub base__: IDxcOperationResult_Vtbl,
    pub HasOutput:
        unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dxcoutkind: DXC_OUT_KIND) -> BOOL,
    pub GetOutput: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        dxcoutkind: DXC_OUT_KIND,
        iid: *const ::windows_core::GUID,
        ppvobject: *mut *mut ::core::ffi::c_void,
        ppoutputname: *mut *mut ::core::ffi::c_void,
    ) -> ::windows_core::HRESULT,
    pub GetNumOutputs: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> u32,
    pub GetOutputByIndex:
        unsafe extern "system" fn(this: *mut ::core::ffi::c_void, index: u32) -> DXC_OUT_KIND,
    pub PrimaryOutput: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> DXC_OUT_KIND,
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq, ::core::fmt::Debug, ::core::clone::Clone)]
pub struct IMalloc(::windows_core::IUnknown);
impl IMalloc {
    pub unsafe fn Alloc(&self, cb: usize) -> *mut ::core::ffi::c_void {
        (::windows_core::Interface::vtable(self).Alloc)(::windows_core::Interface::as_raw(self), cb)
    }
    pub unsafe fn Realloc(
        &self,
        pv: ::core::option::Option<*const ::core::ffi::c_void>,
        cb: usize,
    ) -> *mut ::core::ffi::c_void {
        (::windows_core::Interface::vtable(self).Realloc)(
            ::windows_core::Interface::as_raw(self),
            ::core::mem::transmute(pv.unwrap_or(::std::ptr::null())),
            cb,
        )
    }
    pub unsafe fn Free(&self, pv: ::core::option::Option<*const ::core::ffi::c_void>) {
        (::windows_core::Interface::vtable(self).Free)(
            ::windows_core::Interface::as_raw(self),
            ::core::mem::transmute(pv.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn GetSize(&self, pv: ::core::option::Option<*const ::core::ffi::c_void>) -> usize {
        (::windows_core::Interface::vtable(self).GetSize)(
            ::windows_core::Interface::as_raw(self),
            ::core::mem::transmute(pv.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn DidAlloc(&self, pv: ::core::option::Option<*const ::core::ffi::c_void>) -> i32 {
        (::windows_core::Interface::vtable(self).DidAlloc)(
            ::windows_core::Interface::as_raw(self),
            ::core::mem::transmute(pv.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn HeapMinimize(&self) {
        (::windows_core::Interface::vtable(self).HeapMinimize)(::windows_core::Interface::as_raw(
            self,
        ))
    }
}
::windows_core::imp::interface_hierarchy!(IMalloc, ::windows_core::IUnknown);
unsafe impl ::windows_core::Interface for IMalloc {
    type Vtable = IMalloc_Vtbl;
}
unsafe impl ::windows_core::ComInterface for IMalloc {
    const IID: ::windows_core::GUID =
        ::windows_core::GUID::from_u128(0x00000002_0000_0000_c000_000000000046);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMalloc_Vtbl {
    pub base__: ::windows_core::IUnknown_Vtbl,
    pub Alloc: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        cb: usize,
    ) -> *mut ::core::ffi::c_void,
    pub Realloc: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pv: *const ::core::ffi::c_void,
        cb: usize,
    ) -> *mut ::core::ffi::c_void,
    pub Free:
        unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pv: *const ::core::ffi::c_void),
    pub GetSize: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pv: *const ::core::ffi::c_void,
    ) -> usize,
    pub DidAlloc: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pv: *const ::core::ffi::c_void,
    ) -> i32,
    pub HeapMinimize: unsafe extern "system" fn(this: *mut ::core::ffi::c_void),
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq, ::core::fmt::Debug, ::core::clone::Clone)]
pub struct ISequentialStream(::windows_core::IUnknown);
impl ISequentialStream {
    pub unsafe fn Read(
        &self,
        pv: *mut ::core::ffi::c_void,
        cb: u32,
        pcbread: ::core::option::Option<*mut u32>,
    ) -> ::windows_core::HRESULT {
        (::windows_core::Interface::vtable(self).Read)(
            ::windows_core::Interface::as_raw(self),
            pv,
            cb,
            ::core::mem::transmute(pcbread.unwrap_or(::std::ptr::null_mut())),
        )
    }
    pub unsafe fn Write(
        &self,
        pv: *const ::core::ffi::c_void,
        cb: u32,
        pcbwritten: ::core::option::Option<*mut u32>,
    ) -> ::windows_core::HRESULT {
        (::windows_core::Interface::vtable(self).Write)(
            ::windows_core::Interface::as_raw(self),
            pv,
            cb,
            ::core::mem::transmute(pcbwritten.unwrap_or(::std::ptr::null_mut())),
        )
    }
}
::windows_core::imp::interface_hierarchy!(ISequentialStream, ::windows_core::IUnknown);
unsafe impl ::windows_core::Interface for ISequentialStream {
    type Vtable = ISequentialStream_Vtbl;
}
unsafe impl ::windows_core::ComInterface for ISequentialStream {
    const IID: ::windows_core::GUID =
        ::windows_core::GUID::from_u128(0x0c733a30_2a1c_11ce_ade5_00aa0044773d);
}
#[repr(C)]
#[doc(hidden)]
pub struct ISequentialStream_Vtbl {
    pub base__: ::windows_core::IUnknown_Vtbl,
    pub Read: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pv: *mut ::core::ffi::c_void,
        cb: u32,
        pcbread: *mut u32,
    ) -> ::windows_core::HRESULT,
    pub Write: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pv: *const ::core::ffi::c_void,
        cb: u32,
        pcbwritten: *mut u32,
    ) -> ::windows_core::HRESULT,
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq, ::core::fmt::Debug, ::core::clone::Clone)]
pub struct IStream(::windows_core::IUnknown);
impl IStream {
    pub unsafe fn Read(
        &self,
        pv: *mut ::core::ffi::c_void,
        cb: u32,
        pcbread: ::core::option::Option<*mut u32>,
    ) -> ::windows_core::HRESULT {
        (::windows_core::Interface::vtable(self).base__.Read)(
            ::windows_core::Interface::as_raw(self),
            pv,
            cb,
            ::core::mem::transmute(pcbread.unwrap_or(::std::ptr::null_mut())),
        )
    }
    pub unsafe fn Write(
        &self,
        pv: *const ::core::ffi::c_void,
        cb: u32,
        pcbwritten: ::core::option::Option<*mut u32>,
    ) -> ::windows_core::HRESULT {
        (::windows_core::Interface::vtable(self).base__.Write)(
            ::windows_core::Interface::as_raw(self),
            pv,
            cb,
            ::core::mem::transmute(pcbwritten.unwrap_or(::std::ptr::null_mut())),
        )
    }
    pub unsafe fn Seek(
        &self,
        dlibmove: i64,
        dworigin: STREAM_SEEK,
        plibnewposition: ::core::option::Option<*mut u64>,
    ) -> ::windows_core::Result<()> {
        (::windows_core::Interface::vtable(self).Seek)(
            ::windows_core::Interface::as_raw(self),
            dlibmove,
            dworigin,
            ::core::mem::transmute(plibnewposition.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetSize(&self, libnewsize: u64) -> ::windows_core::Result<()> {
        (::windows_core::Interface::vtable(self).SetSize)(
            ::windows_core::Interface::as_raw(self),
            libnewsize,
        )
        .ok()
    }
    pub unsafe fn CopyTo<P0>(
        &self,
        pstm: P0,
        cb: u64,
        pcbread: ::core::option::Option<*mut u64>,
        pcbwritten: ::core::option::Option<*mut u64>,
    ) -> ::windows_core::Result<()>
    where
        P0: ::windows_core::IntoParam<IStream>,
    {
        (::windows_core::Interface::vtable(self).CopyTo)(
            ::windows_core::Interface::as_raw(self),
            pstm.into_param().abi(),
            cb,
            ::core::mem::transmute(pcbread.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(pcbwritten.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn Commit(&self, grfcommitflags: STGC) -> ::windows_core::Result<()> {
        (::windows_core::Interface::vtable(self).Commit)(
            ::windows_core::Interface::as_raw(self),
            grfcommitflags.0 as _,
        )
        .ok()
    }
    pub unsafe fn Revert(&self) -> ::windows_core::Result<()> {
        (::windows_core::Interface::vtable(self).Revert)(::windows_core::Interface::as_raw(self))
            .ok()
    }
    pub unsafe fn LockRegion(
        &self,
        liboffset: u64,
        cb: u64,
        dwlocktype: LOCKTYPE,
    ) -> ::windows_core::Result<()> {
        (::windows_core::Interface::vtable(self).LockRegion)(
            ::windows_core::Interface::as_raw(self),
            liboffset,
            cb,
            dwlocktype.0 as _,
        )
        .ok()
    }
    pub unsafe fn UnlockRegion(
        &self,
        liboffset: u64,
        cb: u64,
        dwlocktype: u32,
    ) -> ::windows_core::Result<()> {
        (::windows_core::Interface::vtable(self).UnlockRegion)(
            ::windows_core::Interface::as_raw(self),
            liboffset,
            cb,
            dwlocktype,
        )
        .ok()
    }
    pub unsafe fn Stat(
        &self,
        pstatstg: *mut STATSTG,
        grfstatflag: STATFLAG,
    ) -> ::windows_core::Result<()> {
        (::windows_core::Interface::vtable(self).Stat)(
            ::windows_core::Interface::as_raw(self),
            pstatstg,
            grfstatflag.0 as _,
        )
        .ok()
    }
    pub unsafe fn Clone(&self) -> ::windows_core::Result<IStream> {
        let mut result__ = ::std::mem::zeroed();
        (::windows_core::Interface::vtable(self).Clone)(
            ::windows_core::Interface::as_raw(self),
            &mut result__,
        )
        .from_abi(result__)
    }
}
::windows_core::imp::interface_hierarchy!(IStream, ::windows_core::IUnknown, ISequentialStream);
unsafe impl ::windows_core::Interface for IStream {
    type Vtable = IStream_Vtbl;
}
unsafe impl ::windows_core::ComInterface for IStream {
    const IID: ::windows_core::GUID =
        ::windows_core::GUID::from_u128(0x0000000c_0000_0000_c000_000000000046);
}
#[repr(C)]
#[doc(hidden)]
pub struct IStream_Vtbl {
    pub base__: ISequentialStream_Vtbl,
    pub Seek: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        dlibmove: i64,
        dworigin: STREAM_SEEK,
        plibnewposition: *mut u64,
    ) -> ::windows_core::HRESULT,
    pub SetSize: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        libnewsize: u64,
    ) -> ::windows_core::HRESULT,
    pub CopyTo: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pstm: *mut ::core::ffi::c_void,
        cb: u64,
        pcbread: *mut u64,
        pcbwritten: *mut u64,
    ) -> ::windows_core::HRESULT,
    pub Commit: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        grfcommitflags: u32,
    ) -> ::windows_core::HRESULT,
    pub Revert:
        unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows_core::HRESULT,
    pub LockRegion: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        liboffset: u64,
        cb: u64,
        dwlocktype: u32,
    ) -> ::windows_core::HRESULT,
    pub UnlockRegion: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        liboffset: u64,
        cb: u64,
        dwlocktype: u32,
    ) -> ::windows_core::HRESULT,
    pub Stat: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pstatstg: *mut STATSTG,
        grfstatflag: u32,
    ) -> ::windows_core::HRESULT,
    pub Clone: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        ppstm: *mut *mut ::core::ffi::c_void,
    ) -> ::windows_core::HRESULT,
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct LOCKTYPE(pub i32);
impl ::core::marker::Copy for LOCKTYPE {}
impl ::core::clone::Clone for LOCKTYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for LOCKTYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for LOCKTYPE {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for LOCKTYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("LOCKTYPE").field(&self.0).finish()
    }
}
pub const MEMORY_ALLOCATION_ALIGNMENT: u32 = 16u32;
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct STATFLAG(pub i32);
impl ::core::marker::Copy for STATFLAG {}
impl ::core::clone::Clone for STATFLAG {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for STATFLAG {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for STATFLAG {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for STATFLAG {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("STATFLAG").field(&self.0).finish()
    }
}
#[repr(C)]
pub struct STATSTG {
    pub pwcsName: ::windows_core::PWSTR,
    pub r#type: u32,
    pub cbSize: u64,
    pub mtime: FILETIME,
    pub ctime: FILETIME,
    pub atime: FILETIME,
    pub grfMode: STGM,
    pub grfLocksSupported: u32,
    pub clsid: ::windows_core::GUID,
    pub grfStateBits: u32,
    pub reserved: u32,
}
impl ::core::marker::Copy for STATSTG {}
impl ::core::clone::Clone for STATSTG {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for STATSTG {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("STATSTG")
            .field("pwcsName", &self.pwcsName)
            .field("type", &self.r#type)
            .field("cbSize", &self.cbSize)
            .field("mtime", &self.mtime)
            .field("ctime", &self.ctime)
            .field("atime", &self.atime)
            .field("grfMode", &self.grfMode)
            .field("grfLocksSupported", &self.grfLocksSupported)
            .field("clsid", &self.clsid)
            .field("grfStateBits", &self.grfStateBits)
            .field("reserved", &self.reserved)
            .finish()
    }
}
impl ::windows_core::TypeKind for STATSTG {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for STATSTG {
    fn eq(&self, other: &Self) -> bool {
        self.pwcsName == other.pwcsName
            && self.r#type == other.r#type
            && self.cbSize == other.cbSize
            && self.mtime == other.mtime
            && self.ctime == other.ctime
            && self.atime == other.atime
            && self.grfMode == other.grfMode
            && self.grfLocksSupported == other.grfLocksSupported
            && self.clsid == other.clsid
            && self.grfStateBits == other.grfStateBits
            && self.reserved == other.reserved
    }
}
impl ::core::cmp::Eq for STATSTG {}
impl ::core::default::Default for STATSTG {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct STGC(pub i32);
impl ::core::marker::Copy for STGC {}
impl ::core::clone::Clone for STGC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for STGC {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for STGC {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for STGC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("STGC").field(&self.0).finish()
    }
}
impl STGC {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for STGC {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for STGC {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for STGC {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for STGC {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for STGC {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct STGM(pub u32);
impl ::core::marker::Copy for STGM {}
impl ::core::clone::Clone for STGM {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for STGM {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for STGM {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for STGM {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("STGM").field(&self.0).finish()
    }
}
impl STGM {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for STGM {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for STGM {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for STGM {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for STGM {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for STGM {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct STREAM_SEEK(pub u32);
impl ::core::marker::Copy for STREAM_SEEK {}
impl ::core::clone::Clone for STREAM_SEEK {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for STREAM_SEEK {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for STREAM_SEEK {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for STREAM_SEEK {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("STREAM_SEEK").field(&self.0).finish()
    }
}
